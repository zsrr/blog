---
title: 进程和线程
date: 2017-10-07 20:01:31
tags: [操作系统]
categories: 操作系统

---
10月份开始复习操作系统，学不完了好紧张……  本篇记录操作系统进程和线程的知识，同时推荐一下优达学城关于操作系统不错的课程：[操作系统概论](https://cn.udacity.com/course/introduction-to-operating-systems--ud923)

<!--more-->

# 进程
进程是操作系统资源分配和调度的基本单位，是操作系统结构的基础。
## 地址空间
地址空间分为物理地址空间和虚拟地址空间，前者是对应于物理内存的真实位置。操作系统会为每一个进程分配一个虚拟地址空间。虚拟地址通过页表来映射到物理空间。对于用户进程(内核进程的不太一样，这里不再讲述，只考虑用户进程)，地址空间从上到下大致可以分成如下几块：

- 栈区(Stack): 存放函数的调用信息，函数的参数值，局部变量，返回类型等信息。如果对一个函数进行无限递归，将会出现StackOverflow异常(JVM)。
- 堆区(Heap): 动态分配的内存，程序员可以通过malloc函数来申请内存。
- BSS段：未初始化或者初值为0的全局变量或者静态局部变量。
- 数据段：已经初始化或者初值不为0的全局变量或者静态局部变量。
- 代码段：可执行的代码。

操作系统为一个进程分配的虚拟地址空间大小可能比实际使用的物理内存还要大，当实际使用的内存超出物理内存的时候，将会发生交换(Swapping)。交换意味着将物理内存中的部分数据(通常通过LRU算法选举出)存放到硬盘。
## 进程控制块
操作系统感知进程唯一的方式便是通过进程控制块(Process Control Block, PCB)。进程控制块通常具有如下结构：

- 进程标识符(name): 每个进程都必须有一个唯一的标识符，可以是字符串，也可以是一个数字。在进程创建时被操作系统赋予。
- 进程当前的状态(status): 表示进程的状态(下文会说)。
- 进程相应的程序和数据地址。
- 进程的优先级。对于Linux操作系统来说，一共有140个优先级，从0到139，其中0到99是给real-time tasks准备的，100到139是给用户准备的。一般通过调整nice值来调整优先级，nice值的取值范围是-20到19，默认为0，和真实优先级的对应关系为: Priority = nice + 120。
- cpu现场保护区：当cpu要调度别的进程时，会将上一个进程的状态保存到PCB，状态信息包括寄存器(Register)，程序计数器(Program Counter)，栈指针(Stack Pointer)等等。当在cpu恢复执行时从PCB读取。

## 进程的状态
进程的状态如下所示：
![](http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-07%20%E4%B8%8B%E5%8D%888.48.09.png)
如图所示：

- new: 进程被创建。
- ready: 进程到ready队列准备被调度。
- running: 进程在cpu上执行。
- waiting: 进程发生IO操作或者等待其他硬件设施，如打印机，需要等待。
- terminated: 进程执行完毕或者遇到异常退出。若是还在内存中存在PCB块则成为**僵尸进程**。

## 父进程和子进程
c语言中通过fork函数来创建一个子进程，fork函数返回两次，对于父进程来说，返回的是子进程的PID，对于子进程返回值为0。子进程创建之初，父子进程共享相同的代码段，数据段，堆栈段和物理空间，当任意一个进程对共享变量进行更改的时候，操作系统会复制一份物理空间给子进程，此项特性被称为**写时复制技术**。

在Unix系统当中，init进程是一切进程的父进程。当一个进程的父进程被kill掉的时候，此进程变成孤儿进程被init进程托管。

## 守护进程
通常以d结尾，并在系统启动的时候启动，一直运行到系统关闭。通常用来提供某种服务，例如mysqld进程。

# 线程
在操作系统中，维护一个进程和在CPU上调度进程(上下文切换)的代价是比较大的，因此出现了更为轻量级的单位 -- 线程。

线程隶属于进程，但是在CPU上有一个独立的执行上下文。一个进程的多个线程共享此进程地址空间，不过每个线程拥有自己的程序计数器，栈指针，寄存器等信息。

知乎上有一个很有意思的问题: [操作系统多进程多线程的相关问题？](https://www.zhihu.com/question/48500642)

## 线程同步技术
线程的同步技术主要分成三种，这里只做简单的介绍，多线程的编程技术需要专门详尽的介绍。
### Mutex
**Mutual Exclusion**，即悲观锁，用于保护多个线程的共享变量。
### Condition Variable
类似于Java中的wait/notify机制，达到某个条件继续执行。
### 计数信号量
即Java中的Semaphore，规定只能n个线程同时执行。

## 内核线程和用户线程
首先要来解释一下什么是内核线程和用户线程。
### 内核线程
处于内核空间的线程，由内核直接进行调度，是服务类型的守护进程的一种，用来管理硬件资源，响应用户进程。一个内核线程阻塞不影响其他的内核线程。
### 用户线程
处在用户空间的线程。其调度由用户空间的线程库来实现，创建，调度和管理无需内核的支持。
### 两者之间的关系
用户线程和内核线程之间有三种关系。
#### 一对一关系
一个用户线程绑定一个内核线程，这样将线程的管理交由底层的os去做。缺点就是受制于底层操作系统的规则，并且频繁发生用户态到内核态之间的转变。
#### 多对一关系
一个进程中的所有线程对应于一个内核线程。线程的调度管理交由用户空间的线程库去做。其优点就是完全不受系统底层的限制，缺点是如果任意一个用户线程发生阻塞，则其他线程也得进入阻塞状态，因为是和一个内核线程绑定的。
#### 多对多关系
结合了前两种方法，对于一个进程，其中有些线程是一对一关系，通常这些线程要求更高的优先级或者更快速的响应；某一些线程对应于一个内核线程。

