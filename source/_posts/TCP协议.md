---
title: TCP协议
date: 2017-10-24 23:19:52
tags: [TCP,计算机网络,网络协议]
categories: 计算机网络

---
本篇记录计算机网络中最为重要的协议——TCP协议。由于协议的内容比较多，本篇博客不定时更新。主要参考书籍《TCP/IP详解 卷一》。

<!--more-->

# 简介
TCP(Transmission Control Protocol)协议是面向连接的、可靠的、基于字节流的传输协议。与用户数据报协议(UDP)一同处在OSI七层模型的传输层。

## TCP粘包、拆包问题
采用字节流的设计方式，意味着TCP不提供消息保护边界，这一点与UDP不同，因此可能发生TCP粘包，TCP拆包的问题。举个具体的例子，如发送端发送三次消息，第一次消息为2k，第二次为13k，第三次为5k，那么对于UDP来说，总共要发送三次IP数据包，接收端接收到的是三个完整的数据包(不考虑异常的情况)；对于TCP来说，情况则不相同，加入说socket缓冲区的大小为20k，则三次发送的消息累积起来发送一次，这就造成了粘包的问题。
## TCP头部
一个TCP头部如下所示：
![](http://ok34fi9ya.bkt.clouddn.com/TCP%E5%A4%B4%E9%83%A8.png)

源端口号和目的端口号，还有IP报文中的源IP地址和目的IP地址组成的四元组能够唯一标识一个连接。

序列号(Sequence Number)标识了从发送端到接收端的数据流的一个字节，它是一个32位的无符号数，从0到2^32 - 1，之后再循环到0，这有可能造成**回绕序列号(Project Against Wrapped Sequence number, PAWS)**，就是说在很短的时间内接收端收到序列号相同的数据，但是这两份数据不是同一份数据。此问题需要时间戳选项来解决，下文会谈到。

确认号字段(Acknowledgement)包含的是Ack报文的发送方期待接收的下一个序列号，是最后成功收到的数据字节的序列号加一。

上图中标出了TCP报文的8个字段，其解释如下：

- CWR: 让发送方降低发送的速率，用于TCP的拥塞控制。
- ECE: ECN回显。
- URG: 紧急指针，很少被使用。
- ACK: 确认号字段是有效的，一般连接建立之后会一直开启。
- PSH: 接收方收到数据应该尽快发送给上层应用处理，没被很好的实现。
- RST: 重置连接，一般是用于异常的情况。
- SYN: 初始化连接。
- FIN: 终止连接。

窗口大小用于TCP流量控制，16的字段限制了窗口的大小为65535个字节，可以根据窗口缩放选项对这个值进行缩放。

TCP校验和用于检验数据的有效性，不再详谈。

比较常见的TCP选项包括MSS选项，窗口缩放选项，SACK和TSOPT，下文会说明这些选项的作用。
# 连接管理
## 三握四挥
TCP的连接就是我们老生常谈的“三握四挥”，如图所示：
![](http://ok34fi9ya.bkt.clouddn.com/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5.png)
三次握手的过程：

- 发送端置SYN位，初始化序列号ISN = J, 确认号为0。
- 接收端收到请求，置SYN和ACK位，初始化序列号ISN = K, ACK = J + 1。
- 发送端收到请求，置ACK位，序列号位J + 1，确认号为K + 1。

由上述过程可以看到SYN位是占一个序列号的，占用序列号意味着可以被有效的重传。一般建立连接的重传次数比一般数据重传次数更多。

四次挥手的过程：

- 主动选择关闭的一端置FIN位和ACK位(对最后一次发送数据的确认)，序列号为K, 确认号为L。
- 被动关闭者先发送ACK报文，表明已收到发送端的关闭请求，此关闭请求会通知上层的应用程序，接着被动关闭的一端发送FIN报文。
- 主动关闭的一方发送ACK来告知被动关闭的一方已收到FIN。如果FIN丢失的话，那么发送方重新传输直到收到ACK为止。

## 状态管理
接下来探讨TCP的状态管理，如图所示：

![](http://ok34fi9ya.bkt.clouddn.com/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.png)

为了便于理解，下面是两端连接对应的状态改变图：

![](http://ok34fi9ya.bkt.clouddn.com/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png)

图已经说的很明显了，不想再展开对应的讨论，有关TCP状态转换的讨论，参见：[TCP状态转换图详解](http://blog.csdn.net/wenqian1991/article/details/40110703)
## TIME_WAIT状态存在的必要性
由上图可以看到，当主动关闭的一方最后发送确认接收端发来的FIN的ACK时，会等待一段时间然后才进入CLOSED状态，等待的状态称为TIME_WAIT状态，此状态的时长通常为2MSL(Maximum Segment Lifetime)，MSL是指报文段在网络中的最长的生存时间。这样接收端迟迟收不到发送端的ACK时，会重新发送FIN，若此时发送端已经处于CLOSED状态的话，那么就会发送一个RST报文，接收端就会解释成一个错误。所以等待2个最大段生存期是有必要的。
## 重置报文段
重置报文段即RST报文段，通常用来处理异常的情况：
### 请求一个未打开的端口
如果向服务器请求一个未打开的端口，会收到如下错误信息：

    $ telnet localhost 10000
    Trying ::1...
    telnet: connect to address ::1: Connection refused
此时接收端会发送一个RST报文。
### 请求超时
发送端发送SYN请求连接到发送端接收到接收端发送的SYN这段时间的时长若超出指定范围，那么发送端就会发送RST报文终止连接。
### 终止连接
在正常的情况下，用FIN来终止连接，FIN是在排队数据都已经发送后才被发送出去，不会出现丢失数据的情况，任何时刻，可以用RST来代替FIN来终止一条连接，此时：

- 任何排队的数据都将被丢弃，RST被立即发送出去。
- 接收方说明另一端采用了非正确的方式关闭连接。

当然发生RST的情况肯定不止上面几种，随时更新~
## 连接队列
在并发服务器当中，连接被应用到应用程序之前通常处在两种状态，一是连接尚未完成但是已经收到了SYN；二是连接已经完成，此时处于ESTABLISHED状态。通常操作系统会用两个队列来处理上述不同的情况。

在伯克利套接字API中可以通过设置backlog的大小来限制这两个队列的总和。在Linux中，将会有下面的规则：

- 当一个新的请求到来时，将会检查系统范围内的参数**net.ipv4.tcp_max_syn_backlog**，其默认值为1000，如果处于SYN_RCVD状态的连接数目超出了这一个值，新来的请求将会被拒绝。
- 每一个侦听的应用程序都维护一个连接队列，此队列存放的是已经进入ESTABLISHED状态但是未被应用程序所接受。应用程序会对这个队列的大小进行限制，默认为128。
- 如果侦听节点的连接队列还有剩余空间的话，TCP才会对到来的SYN发送应答完成连接。客户端完成连接之后，服务器侦听节点可能还未知道有次连接，此时后续客户端传送的数据被放到队列之中。
- 如果侦听节点连接队列没有足够的空间的话，那么TCP将会选择延迟对SYN做出响应。如果系统控制变量**net.ipv4.tcp_abort_on_**被设定，则会发送RST报文。

## TCP的路径MTU发现
先来看一下TCP的MSS选项和路径MTU的含义：

MSS(Maximum Segment Size)最大段大小为所允许从对方接收到的最大报文段，只包含TCP的数据不包含头部的大小。当建立一条连接的时候，通信双方需要在SYN报文指定MSS选项来说明自己能接收的最大段的大小，最大段的默认大小为536字节，典型的为1460个字节。最大段大小不是双方协商的结果，而是一个限定的数值。

路径MTU即路由路径中所有网络报文段最大传输单元(Maximum  Transmission Unit)的最小值，TCP应该根据此值来设定发送段的大小，以此来避免分片。传统的路径MTU的测量是通过ICMP传送PTB消息来实现的，TCP协议可以采取分组层路径最大传输单元发现来避免对ICMP的使用。

传统的TCP路径MTU发现过程如下：TCP使用对外接口(原版书当中为outgoing interface，我不懂是什么意思)所声明的最大传输单元的最小值，或者根据对方所规定的MSS来决定自己所要发送段的最大大小(SMSS)。如果对方没有指明MSS，则采用默认的536字节，但是这种情况很少。

一旦SMSS选定了初始值，那么就会置IPv4数据报的DF位(Don't Fragment，不要进行IP分片)。如果接收到了PTB(Packet Too Big)消息，则会调整发送段的大小进行重传。如果PTB中存在推荐的PMTU，发送方则会据此进行设置。如果不存在的话，则发送方会尝试多个数值(可以根据二分搜索来进行选择)。

# 超时重传
如前所述，TCP是一种可靠的传输协议。因此TCP提供了一系列机制来面对各种异常的情况。为了保证数据传输的正确性，TCP会重传已经丢失的包。重传可以基于两种机制：一是基于时间；而是基于确认信息的构成。
## 基于计时器的重传机制
TCP在发送数据时会维护一个计时器，如果在指定时间内没有收到发送数据的ACK的话，则重新发送。计时器的超时时间称为RTO(Retransmission Timeout)。

TCP拥有两个值来决定如何重传一个报文段。R1表示重传的次数，R2表示何时应该放弃此连接。R1和R2应该至少分别为3次和100秒。连接的建立过程和传输过程不太相同，针对SYN报文的R2值为3分钟。

RTO应该根据RTT来进行设置，RTT为发送一个数据报到接到此数据报ACK所需的时间。关于其中的复杂的算法不再展开讨论(我鶸)，有关如何通过RTT来确定RTO，参见：[TCP中RTT和RTO的计算方法](http://blog.csdn.net/yusiguyuan/article/details/39997575)
## 快速重传
快速重传多用于失序包。当接收端得到一个失序包时，立即返回重复ACK(普通情况下会有延迟)，此ACK是最近一次使接收端窗口移动的数据段的确认号。

当收到期盼序列号的后续分组时，意味着两种情况，一是之前期待的数据包已经丢失，二是仅仅是延迟到达，一般我们不能辨别这两种情况，所以发送端需要等待一定数目的重复ACK，当达到阈值的时候开始重发丢失的数据。
## 基于选择确认的重传
首先要介绍一下SACK选项：

因为有可能接收到失序的数据，所以接收端的窗口可能存在漏洞，为了告知发送端这些漏洞，TCP报文提供了SACK选项, 来告知发送端丢失了哪些数据，来让发送端在一个RTT内填补多个空缺。

SACK选项是否开启是在三次握手阶段确立的，需要两方同时开启此选项才会生效。SACK信息包含了接收端成功接收的序列号范围，每一个范围称作一个SACK块，由于TCP数据大小是有限的，所以一般只包含3个SACK块。

上面所提到的快速重传，接收端在发送重复ACK时，可以发送SACK来告知发送端丢失了哪些数据。当不开启SACK时，快速重传只能重传一个报文段；开启SACK之后可以填补多个空缺。