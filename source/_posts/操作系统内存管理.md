---
title: 操作系统内存管理
date: 2017-10-09 16:30:41
tags: [操作系统]
categories: 操作系统

---
本篇介绍操作系统内存管理的基本方式，主要集中于页式管理。

<!--more-->

# 逻辑地址和物理地址
在介绍地址相关概念之前，先介绍一下地址空间的概念。
## 地址空间
地址空间分为物理空间和虚拟空间。物理空间是实际物理内存的存储单元。虚拟空间是操作系统分配给每个进程的地址空间，是对物理层的抽象，在32位的操作系统当中，系统为每一个进程分配的虚拟空间的大小为2 ^ 32 = 4GB。虚拟空间的大小有可能比实际物理内存还要大。
## 物理地址
物理地址也叫做实地址，放在地址总线上，以电子的形式存在，对应于真实物理内存的存储单元。
## 逻辑地址
对应于虚拟空间中的地址，实际上是一个段内偏移量，需要被MMU(CPU的内存管理单元)转换成线性地址，并最终转换成物理地址(如果没有开启分页机制，那么线性地址就是物理地址)。例如在C语言编程的时候，读到的指针的值就是一个逻辑地址。
在保护模式下(没有分段或者分页机制的情况下)，逻辑地址和物理地址相等。

以上知识做最基本的介绍，有关的更多内容参见：[逻辑地址，物理地址，线性地址](https://vosamo.github.io/2016/01/VA2PA/)
# 页式管理
## 基本概念
页式管理的逻辑是将逻辑地址空间分成大小相等的页，物理地址空间被分成相应的页框。页式管理的地址结构分成两部分，一部分是页号(Virtual Page Number, VPN)，在32位操作系统当中占据20位，12位用来表示位移量，页的大小一般是和位移量有关的，例如对于上述所说，12位表示位移量则页的大小为: 2 ^ 12 = 4kb。
## 页表
对于页式管理来说，需要有一个从虚拟内存中的页到物理内存中页框的映射，这个映射表就是页表(Page Table)。页表只能存在于主存当中，不能通过交换技术存到二级存储设备。每一个进程都有自己的独立的页表，PCB块中存在指向本进程页表的指针，当CPU调度到某个进程时，会将其页表加载到CR3寄存器。对于某个VPN来说，有一个物理页框页号(Physical Frame Number)与之对应，物理页号加上最后的偏移量是最终的物理地址。

现在只考虑一级页表的情况，当进程初始化时，其地址空间中对应的所有页都会在页表中存在映射，但是其对应的页框可能并未被初始化。考虑在32位系统当中，一个页表项的大小为4B, 一个页的大小为4kb，页的数目为2 ^ 32 / 2 ^ 12 = 2 ^ 20。所以页表所占的内存大小为：2 ^ 20 \* 4B = 4MB。即一个进程要在内存中存在一个大小为4MB的页表。
### PTE
PTE(Page Table Entry)可以理解成页表当中一行。在32位操作系统中其大小为4B。除了保存物理页号之外，还存有很多位来标记内存的状态，下面介绍几个常见的位：

- Present: 用来标记页是否对应实际内存的存储单元，当页对应的物理内存被交换到二级存储设备中时，此位实效。
- Dirty: 用来标记内存是否对文件进行写入操作。操作系统可以根据此位来决定是否对硬盘文件进行更新操作。
- Access: 用来标记内存访问，交换技术中的LRU算法可以根据此位确定要交换到硬盘的内存。
- RWX: 用来标记内存的访问权限。

### 分级页表
上面曾经提到过在32位系统当中，1个进程对应的页表的大小为4MB，这个数字是很可怕的。当处于64位时，页表的大小变得难以接受，而且页表无法通过交换存储到硬盘空间。一级页表浪费内存的关键是**对于一个进程，初始化之后无论某个页是否被使用，在页表中都有对应的项。**因此需要采用多级页表来减小页表的大小。

以下拿二级页表来说明，多级与之类似, 二级页表的设计如图所示:

![](http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-13%20%E4%B8%8B%E5%8D%883.42.21.png)

当采用二级页表的时候，原来的虚拟地址被分成了三个部分(原来是VPN + Offset)，Offset部分不变，VPN被拆成两部分, 第一个是Outer page table的位置，第二个指向了Inner page table的位置，如图所示：

![](http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-13%20%E4%B8%8B%E5%8D%883.45.53.png)

Inner Page Table只有在需要的时候才会被分配，这是节省内存的关键所在。下面假设有一个16位的操作系统，前2位用来表示Outer Page Table中的位置，中间4位表示Inner Page Table中的位置，最后10位表示Offset，先计算一下一级页表的内存占用情况：

一级页表中VPN占了6位，所以有2 ^ 6 = 64个页表项，一个页表项占了2B，所以一个一级页表占用的内存128B。

16位操作系统，操作系统为一个进程分配的虚拟内存的大小为: 2 ^ 16 = 64KB，假设前16KB被分配使用。
对于上述的情况，描述Outer Page Table的位置占了2个位，所以外层表有四个项，占了8B。所以最多有4个Inner Page Table，一个内层表有2 ^ 4 = 16个项，占了32B, 4个表加起来有64个项(和之前一级列表相同)。这里就很明白了，64KB的虚拟内存被平摊到4个表中，所以一个表能够平摊16KB，所以对于上述假设的情况只有一个内层表被分配，页表占的总大小为：8 + 32 = 40B，比之前的128B小了很多。
### Inverted Page Table
既然操作系统为每一个进程分配一个页表，那为什么不共享一个页表呢？Inverted Page Table就是这么一个共享的页表。其在内存中只有一份。其中的每一项都和物理页框相对应。

因为要分清是那个进程的，所以项的结构也要发生改变，增加了一个PID，用来标记所属的进程。还有一个P, 用来标记虚拟内存中的页号。项在页表中的位置就是物理页号。

Inverted Page Table的主要问题就是线性查找所带来的性能负担。为了解决这个问题，先对PID和P求哈希值，得出的哈希值对应页表的一项。因为可能产生哈希冲突，所以页表的每一项都维持一个链表。链表的每一项记录着PID和P值。
### TLB
TLB(Translation Lookaside Buffer)是用来加速查询的内存管理单元。是一个很小的缓存，每一项都存储着一个PTE。此缓存主要解决多级页表查询带来的时间问题。
# 交换
上面说到操作系统为每个进程分配的地址空间大小可以远大于实际物理内存。对于多进程的操作系统来讲，这会对物理内存造成竞争，所以需要交换(Paging)技术来将实际物理内存的部分内容转移到其他的存储设备。交换之后，PTE中的Present位变成0。

交换在两种情况下发生，一是物理内存的使用达到了上限；二是CPU的使用达到了下限，此时各个进程可能处在不怎么工作的状态。操作系统力求交换对于各进程的影响最小。

为了确立交换的页，操作系统主要查看PTE中的Access位和Dirty位。查看Access位是为了根据LRU算法来得出要交换的页；查看Dirty位是为了得出不用对硬盘执行写入的页，此种页优先被交换。另外，**持有内核状态的页一定不能被交换。**

当访问某个页时，MMU发现其PTE中的Present位为0，则发起一个错误，此错误被操作系统来处理。操作系统根据之前是否发生过交换来决定是否从硬盘中取出内容，如果是，则在DRAM中重新分配一个页框，更新页表与程序计数器，刚才对于此页访问指令重新执行。

