---
title: 操作系统调度算法和排程器
date: 2017-10-07 23:06:47
tags: [操作系统]
categories: 操作系统

---
本篇记录操作系统常见的调度算法和Linux几个主要的排程器。

<!--more-->

# 调度算法
对于多进程/线程(以下统称为任务)的环境，操作系统需要对任务进行调度。调度器(Scheduler)的主要作用就是决定在Ready队列中的任务哪一个被当前CPU执行，这就需要按照一定的规则来调度。下面介绍几个常见的调度算法。
## FCFS
First Come First Served, 此算法是最为简单的调度算法，只需维护一个简单的队列即可。先到的任务优先被调度。

此算法属于非剥夺式算法，这里需要说明。剥夺式算法(Preemptive)是指当有新的任务进入Ready队列中时，排程器会根据所采取的算法来决定是否优先安排此任务，如果是，则中断(interrupt)CPU上正在执行的任务。非剥夺式算法就是指一个任务被调度之后无论它运行时间有多长，都会一直运行下去。

因为此算法为非剥夺式算法，所以有利于长任务的执行(CPU密集型)，不利于交互式任务的执行。
## SJF
Shortest Job First，预计运行时间最短的任务先执行，属于剥夺式算法。

对于任务的运行时间，一个可靠的预计方案是看之前此任务的运行时间，历史是最可靠的武器。

此算法有利于短作业的执行，对于长作业来说，如果排在之前的短作业太多，可能长时间处在“饥饿”状态。
## 高响应比优先调度算法
为了弥补上面SJF算法可能造成长任务饥饿的缺陷，可以采取高响应比优先的方式。响应比的计算公式如下：

    响应比 = 等待时间 + 要求服务时间 ／ 要求服务时间
刚开始，响应比主要取决于要求服务时间的大小，所以短作业得以优先被调度。随着长作业等待时间的增长，其响应比也越来越大，最终超过短作业的响应比，得以调度执行，解决了饥饿的问题。
## 优先级调度算法
顾名思义，是根据任务的优先级来调度的，属于剥夺式算法。

### Priority Inversion
此问题的发生场景在于如果一个优先级较低的线程先获得了锁，在之后一个优先级较高的线程要获取锁时(获取失败进入等待队列)，只能等到优先级低的线程释放锁之后(在此期间可能有多个线程被调度)才能得以继续执行，这就相当于优先级高的线程的执行被优先级低的线程牵绊住了。
### Boost Priority
对于上述问题的解决方案是暂时将持有锁的任务的优先级提高至要得到锁的任务的优先级，这样能保证持有锁的任务优先被调度，以使要求锁的任务能尽快获得到锁。当任务释放锁的时候，优先级再降低到原来的等级。
## 时间片轮询法
给定一定长度的时间片，当一个任务用完这段时间片时，无论此任务有没有执行完，都会调度下一个任务(可以和之前介绍的优先级调度算法或者SJF结合)。

对于CPU密集型任务，我们通常希望它的完成时间尽量的小，所以分配的时间片尽可能长一些。而对于IO密集型的，或者说交互式的任务，我们希望等待时间尽量的小，所以分配的时间片尽可能短一些。

注意一个任务可能在没消耗完时间片的情况下发生了IO操作进入等待状态，这时候也会调度其他的任务。
## 多级反馈队列调度算法
此方法结合了上述几种算法的种种优点，其工作方式如下：

首先分成若干个队列，优先级最高的队列拥有最短的时间片长度，通常用来处理IO型任务。优先级最低的队列拥有最长的时间片长度，通常用来处理CPU密集型的任务。

新的任务到达之时，如果它以前在反馈队列中存在过，则把此任务插放在原来那一级别的队列的尾部；如果是第一次进入反馈队列，则先插放在第一级队列尾部。

反馈过程：任务被安排在某一级队列，如果在一个时间片内发生了IO操作，则排程器认为此任务安排在此队列正合适。如果在一个时间片内没有完成任务，则排程器认为此任务需要更多的CPU操作，把它插在下一级队列的尾部。如果一个任务老是在一个时间片内发生IO操作的话，则把它安插在上一级队列的尾部。

此算法属于剥夺式算法，优先调度优先级高的队列中的任务，当某一级队列中没有任务的时候再对下一级队列的任务进行调度。如果任务在执行过程中，优先级高的队列有新的任务出现，则发生中断。
# Scheduler
主要介绍Linux操作系统的O(1)排程器和CFS排程器。
## O(1)排程器
O(1)排程器在Linux Kernel 2.5版本引入。其名称的由来是在一个时间点无论运行着多少个任务，添加任务和选择下一个要执行的任务都花费常量时间。

其主要思想是模仿的多级反馈队列调度算法，不过对于优先级较高的进程，分配较长的时间片，优先级低的进程分配较长的时间片(下面会说明原因)，这一点要和多级反馈队列调度算法加以区分。

内部维持两个数组：Active数组和Expired数组，如图所示：
![](http://ok34fi9ya.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-08%20%E4%B8%8A%E5%8D%8812.10.10.png)
当任务用光时间片的时候，会被安排到Expired数组中，此后不再进行调度。当Active数组中的所有任务都安排到Expired数组中时，交换两个数组的指针，继续调度未完成的任务。

下面来说明此排程器对优先级高的任务分配较长时间片的原因：

上面曾经说过，一个任务可能在没有用完时间片的情况下发生IO操作进入等待状态，此时会调度其余的任务。对于IO型的任务，给予更高的优先级和更长的时间片，当发生IO操作时，任务并没有消耗完时间片所以不会提早进入Expired数组，能够以更高的频率执行。
## CFS
O(1)排程器有很多的缺点，对于在Expired数组中的任务只能等Active数组空了之后才能再次被调度。为了弥补这个缺点，Linux Kernel 2.6版本引入了CFS(Completely Fair Scheduler)，即完全公平调度器。

内部维持一个红黑树，如图所示：
![](http://ok34fi9ya.bkt.clouddn.com/BFD7F44D3F6A2D44044BF42829B073AA.jpg)
节点表示的是一个任务的Virtual Runtime。左下角的vruntime值是最小的，优先被调度。任务在执行过程中，vruntime值周期性增大，并与树中最小的vruntime进行比较，如果比它小，则继续执行，比它大的话，则中断，并重新安插到树中。对于优先级高的任务，vruntime值增大的周期比较长，优先级低的任务增大周期较短。
